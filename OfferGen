# =========================================================
# BigFix Offer Action Generator (Install / Update / Remove)
# Baseline: Offers-2025-09-24-v7 (Fixed layout + App Desc + XML bools)
# =========================================================

Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing
Add-Type -AssemblyName System.Web

# =========================
# CONFIG (hardcoded)
# =========================
$LogFile = "C:\temp\BigFixOfferGenerator.log"
$CustomSiteName = "Test Group Managed (Workstations)"

# Fixlet Action name inside each Fixlet
$FixletActionName_Default = "Action1"

# Hardcoded group IDs for the two rounds
$QA_GroupIdWithPrefix     = "00-12345"
$Deploy_GroupIdWithPrefix = "00-67890"

# Offer settings
$OfferDefaults = @{
    PreActionShowUI = $false
    RetryCount      = 3
    RetryWaitISO    = "PT1H"
    StartOffsetISO  = "PT0S"        # starts now
    EndOffsetISO    = "P365DT0S"    # ends in 1 year
    Reapply         = $true
    ContinueOnErr   = $true
    ActiveUserReq   = "NoRequirement"
    ActiveUserType  = "AllUsers"
}

# Behavior toggles
$IgnoreCertErrors           = $true
$DumpFetchedXmlToTemp       = $true
$AggressiveRegexFallback    = $true
$SaveActionXmlToTemp        = $true
$PostUsingInvokeWebRequest  = $true

# =========================
# UTIL / LOGGING
# =========================
function Encode-SiteName([string]$Name) {
    $enc = [System.Web.HttpUtility]::UrlEncode($Name, [System.Text.Encoding]::UTF8)
    $enc = $enc -replace '\+','%20' -replace '\(','%28' -replace '\)','%29'
    return $enc
}
function Get-BaseUrl([string]$ServerInput) {
    if (-not $ServerInput) { throw "Server is empty." }
    $s = $ServerInput.Trim()
    if ($s -notmatch '^(?i)https?://') {
        if ($s -match ':\d+$') { $s = "https://$s" } else { $s = "https://$s:52311" }
    }
    return $s.TrimEnd('/')
}
function Join-ApiUrl([string]$BaseUrl,[string]$RelativePath) {
    $rp = if ($RelativePath.StartsWith("/")) { $RelativePath } else { "/$RelativePath" }
    $BaseUrl.TrimEnd('/') + $rp
}
function Get-AuthHeader([string]$User,[string]$Pass) {
    $pair  = "$User`:$Pass"
    $bytes = [System.Text.Encoding]::ASCII.GetBytes($pair)
    "Basic " + [Convert]::ToBase64String($bytes)
}
function LogLine($txt) {
    try {
        $line = "{0}  {1}" -f (Get-Date -Format 'u'), $txt
        if ($LogBox) { $LogBox.AppendText($line + "`r`n"); $LogBox.SelectionStart = $LogBox.Text.Length; $LogBox.ScrollToCaret() }
        Add-Content -Path $LogFile -Value $line
    } catch {}
}
function Get-NumericGroupId([string]$GroupIdWithPrefix) {
    if ($GroupIdWithPrefix -match '^\d{2}-(\d+)$') { return $Matches[1] }
    return ($GroupIdWithPrefix -replace '[^\d]','')
}
function SafeEscape([string]$s) {
    if ($null -eq $s) { return "" }
    [System.Security.SecurityElement]::Escape($s)
}
function To-XmlBool([bool]$b) { if ($b) { 'true' } else { 'false' } }

# Clean product name from Fixlet title (strip Install/Update/Remove prefixes, trailing " Win")
function Parse-FixletTitleToProduct([string]$Title) {
    $t = [string]$Title
    $t = $t -replace '^\s*(?i)(Install|Update|Remove)\s*[:\-]\s*',''
    $t = $t -replace '^\s*(?i)Update:\s*',''
    $t = $t -replace '\s+Win$',''
    $t.Trim()
}

# =========================
# HTTP
# =========================
if ($IgnoreCertErrors) { try { [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true } } catch { } }
[System.Net.ServicePointManager]::Expect100Continue = $false

function HttpGetXml {
    param([string]$Url,[string]$AuthHeader)
    $req = [System.Net.HttpWebRequest]::Create($Url)
    $req.Method = "GET"
    $req.Accept = "application/xml"
    $req.Headers["Accept-Encoding"] = "gzip, deflate"
    $req.AutomaticDecompression = [System.Net.DecompressionMethods]::GZip -bor [System.Net.DecompressionMethods]::Deflate
    if ($AuthHeader) { $req.Headers["Authorization"] = $AuthHeader }
    $req.ProtocolVersion = [Version]"1.1"
    $req.PreAuthenticate = $true
    $req.AllowAutoRedirect = $false
    $req.Timeout = 45000
    try {
        $resp = $req.GetResponse()
        try {
            $sr = New-Object IO.StreamReader($resp.GetResponseStream(), [Text.Encoding]::UTF8)
            $content = $sr.ReadToEnd(); $sr.Close()
        } finally { $resp.Close() }
        return $content
    } catch {
        throw ($_.Exception.GetBaseException().Message)
    }
}

function Post-XmlFile-InFile {
    param([string]$Url,[string]$User,[string]$Pass,[string]$XmlFilePath)
    try {
        $pair  = "$User`:$Pass"
        $bytes = [System.Text.Encoding]::ASCII.GetBytes($pair)
        $basic = "Basic " + [Convert]::ToBase64String($bytes)
        $resp = Invoke-WebRequest -Method Post -Uri $Url `
            -Headers @{ "Authorization" = $basic } `
            -ContentType "application/xml" `
            -InFile $XmlFilePath `
            -UseBasicParsing
        if ($resp.Content) { LogLine "POST response: $($resp.Content)" }
    } catch {
        $respErr = $_.Exception.Response
        if ($respErr -and $respErr.GetResponseStream) {
            $rs = $respErr.GetResponseStream()
            $sr = New-Object IO.StreamReader($rs, [Text.Encoding]::UTF8)
            $errBody = $sr.ReadToEnd(); $sr.Close()
            throw "Invoke-WebRequest POST failed :: $errBody"
        }
        throw ($_.Exception.Message)
    }
}

# =========================
# OFFER XML BUILDER (console title: "<Kind>: <DisplayName>: <Phase> Offer")
# =========================
function Build-OfferXml {
    param(
        [string]$UiBaseTitle,     # fixlet title (for console ActionUITitle context)
        [string]$DisplayName,     # derived from title for user-facing text
        [string]$SiteName,
        [string]$FixletId,
        [string]$FixletActionName,
        [string]$GroupRelevance,
        [string]$Kind,            # "Install" | "Update" | "Remove"
        [string]$Phase,           # "QA" | "Deploy"
        [string]$OfferDescription # from UI (Application Description)
    )

    # UI title should be just the clean product name
    $uiTitleMessage  = SafeEscape($DisplayName)
    $siteEsc         = SafeEscape($SiteName)
    $fixletIdEsc     = SafeEscape($FixletId)
    $actionNameEsc   = SafeEscape($FixletActionName)
    $groupSafe       = if ([string]::IsNullOrWhiteSpace($GroupRelevance)) { "" } else { $GroupRelevance }
    $groupSafe       = $groupSafe -replace ']]>', ']]]]><![CDATA[>'

    # Texts by kind
    switch -Regex ($Kind) {
        '^(?i)install$' { $ing='Installing'; $cat='Install'; $verb='install' }
        '^(?i)remove$'  { $ing='Removing' ; $cat='Remove' ; $verb='remove'  }
        default         { $ing='Updating' ; $cat='Update' ; $verb='update'  }
    }
    $offerMsg   = SafeEscape(("({0} to {1}.  Please wait...)" -f $ing, $DisplayName))
    $offerTitle = SafeEscape(("{0}: {1}: {2} Offer" -f $cat, $DisplayName, $Phase))
    # Use UI description if provided; otherwise a default
    $offerDescInput = if ([string]::IsNullOrWhiteSpace($OfferDescription)) { "This offer will $verb $DisplayName." } else { $OfferDescription }
    $offerDesc  = SafeEscape($offerDescInput)
    $offerCat   = SafeEscape($cat)

@"
<?xml version="1.0" encoding="UTF-8"?>
<BES xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="BES.xsd">
  <SourcedFixletAction>
    <SourceFixlet>
      <Sitename>$siteEsc</Sitename>
      <FixletID>$fixletIdEsc</FixletID>
      <Action>$actionNameEsc</Action>
    </SourceFixlet>
    <Target>
      <CustomRelevance><![CDATA[$groupSafe]]></CustomRelevance>
    </Target>
    <Settings>
      <!-- Messages -->
      <ActionUITitle>$uiTitleMessage</ActionUITitle>
      <PreActionShowUI>$(To-XmlBool $OfferDefaults.PreActionShowUI)</PreActionShowUI>
      <HasRunningMessage>true</HasRunningMessage>
      <RunningMessage><Text>$offerMsg</Text></RunningMessage>

      <!-- Execution -->
      <HasTimeRange>false</HasTimeRange>
      <HasStartTime>true</HasStartTime>
      <StartDateTimeLocalOffset>$($OfferDefaults.StartOffsetISO)</StartDateTimeLocalOffset>
      <HasEndTime>true</HasEndTime>
      <EndDateTimeLocalOffset>$($OfferDefaults.EndOffsetISO)</EndDateTimeLocalOffset>
      <UseUTCTime>false</UseUTCTime>

      <!-- Reapply & Retry -->
      <Reapply>$(To-XmlBool $OfferDefaults.Reapply)</Reapply>
      <HasReapplyLimit>false</HasReapplyLimit>
      <HasReapplyInterval>false</HasReapplyInterval>
      <HasRetry>true</HasRetry>
      <RetryCount>$($OfferDefaults.RetryCount)</RetryCount>
      <RetryWait Behavior="WaitForInterval">$($OfferDefaults.RetryWaitISO)</RetryWait>

      <!-- Defaults -->
      <ActiveUserRequirement>$($OfferDefaults.ActiveUserReq)</ActiveUserRequirement>
      <ActiveUserType>$($OfferDefaults.ActiveUserType)</ActiveUserType>
      <HasWhose>false</HasWhose>
      <PreActionCacheDownload>false</PreActionCacheDownload>
      <HasTemporalDistribution>false</HasTemporalDistribution>
      <ContinueOnErrors>$(To-XmlBool $OfferDefaults.ContinueOnErr)</ContinueOnErrors>
      <PostActionBehavior Behavior="Nothing"></PostActionBehavior>

      <!-- Offer tab -->
      <IsOffer>true</IsOffer>
      <OfferCategory>$offerCat</OfferCategory>
      <OfferDescription>$offerDesc</OfferDescription>
    </Settings>

    <!-- Console action title -->
    <Title>$offerTitle</Title>
  </SourcedFixletAction>
</BES>
"@
}

# =========================
# GUI (root grid: inputs → buttons → log)
# =========================
$form = New-Object System.Windows.Forms.Form
$form.Text = "BigFix Offer Action Generator"
$form.StartPosition = "CenterScreen"
$form.Size = New-Object System.Drawing.Size(820, 720)
$form.MinimumSize = New-Object System.Drawing.Size(820, 600)

# Root layout (3 rows)
$root = New-Object System.Windows.Forms.TableLayoutPanel
$root.Dock = 'Fill'
$root.AutoSize = $false
$root.RowCount = 3
$root.ColumnCount = 1
$root.Padding = '10,10,10,10'
$root.RowStyles.Add((New-Object System.Windows.Forms.RowStyle([System.Windows.Forms.SizeType]::AutoSize)))     # inputs
$root.RowStyles.Add((New-Object System.Windows.Forms.RowStyle([System.Windows.Forms.SizeType]::AutoSize)))     # buttons
$root.RowStyles.Add((New-Object System.Windows.Forms.RowStyle([System.Windows.Forms.SizeType]::Percent,100)))  # log fill
$root.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Percent,100)))
$form.Controls.Add($root)

# ----- Inputs grid (labels/fields) -----
$grid = New-Object System.Windows.Forms.TableLayoutPanel
$grid.Dock = 'Top'
$grid.AutoSize = $true
$grid.AutoSizeMode = 'GrowAndShrink'
$grid.ColumnCount = 2
$grid.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Absolute, 200)))  # labels
$grid.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Percent, 100)))  # inputs

function Add-Row([string]$labelText, [System.Windows.Forms.Control]$ctrl) {
    $lbl = New-Object System.Windows.Forms.Label
    $lbl.Text = $labelText
    $lbl.AutoSize = $true
    $lbl.Margin = '0,6,12,6'

    $ctrl.Margin = '0,2,0,6'
    $ctrl.Anchor = 'Left,Right'

    $grid.RowCount += 1
    $grid.RowStyles.Add((New-Object System.Windows.Forms.RowStyle([System.Windows.Forms.SizeType]::AutoSize)))
    $grid.Controls.Add($lbl, 0, $grid.RowCount - 1)
    $grid.Controls.Add($ctrl, 1, $grid.RowCount - 1)
}

# Server (locked, white background)
$tbServer = New-Object System.Windows.Forms.TextBox
$tbServer.Text = "https://test.server:52311"
$tbServer.ReadOnly = $true
$tbServer.BackColor = [System.Drawing.SystemColors]::Window
Add-Row "BigFix Server:" $tbServer

# Username / Password
$tbUser = New-Object System.Windows.Forms.TextBox
Add-Row "Username:" $tbUser

$tbPass = New-Object System.Windows.Forms.MaskedTextBox
$tbPass.PasswordChar = '*'
Add-Row "Password:" $tbPass

# Fixlet IDs
$tbFixletInstall = New-Object System.Windows.Forms.TextBox
Add-Row "Fixlet ID (Install):" $tbFixletInstall

$tbFixletUpdate = New-Object System.Windows.Forms.TextBox
Add-Row "Fixlet ID (Update):" $tbFixletUpdate

$tbFixletRemove = New-Object System.Windows.Forms.TextBox
Add-Row "Fixlet ID (Remove):" $tbFixletRemove

# Application Description (multiline)
$tbAppDesc = New-Object System.Windows.Forms.TextBox
$tbAppDesc.Multiline = $true
$tbAppDesc.ScrollBars = 'Vertical'
$tbAppDesc.Height = 110
$tbAppDesc.Anchor = 'Left,Right'
$tbAppDesc.Margin = '0,2,0,6'
$lblDesc = New-Object System.Windows.Forms.Label
$lblDesc.Text = "Application Description (Offer tab):"
$lblDesc.AutoSize = $true
$lblDesc.Margin = '0,6,12,6'
$grid.RowCount += 1
$grid.RowStyles.Add((New-Object System.Windows.Forms.RowStyle([System.Windows.Forms.SizeType]::AutoSize)))
$grid.Controls.Add($lblDesc, 0, $grid.RowCount - 1)
$grid.Controls.Add($tbAppDesc, 1, $grid.RowCount - 1)

# Add inputs grid to root row 0
$root.Controls.Add($grid, 0, 0)

# ----- Buttons row (under inputs) -----
$btnPanel = New-Object System.Windows.Forms.TableLayoutPanel
$btnPanel.Dock = 'Top'
$btnPanel.AutoSize = $true
$btnPanel.AutoSizeMode = 'GrowAndShrink'
$btnPanel.ColumnCount = 1
$btnPanel.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Percent,100)))

$btnQA = New-Object System.Windows.Forms.Button
$btnQA.Text = "Create QA Offers (Install / Update / Remove)"
$btnQA.Height = 34
$btnQA.Dock = 'Top'
$btnQA.Margin = '0,4,0,6'
$btnPanel.Controls.Add($btnQA)

$btnDeploy = New-Object System.Windows.Forms.Button
$btnDeploy.Text = "Create Deploy Offers (Install / Update / Remove)"
$btnDeploy.Height = 34
$btnDeploy.Dock = 'Top'
$btnDeploy.Margin = '0,0,0,6'
$btnPanel.Controls.Add($btnDeploy)

# Add buttons panel to root row 1
$root.Controls.Add($btnPanel, 0, 1)

# ----- Log box (fills remaining space) -----
$LogBox = New-Object System.Windows.Forms.TextBox
$LogBox.Multiline = $true
$LogBox.ScrollBars = 'Vertical'
$LogBox.ReadOnly = $false
$LogBox.WordWrap = $false
$LogBox.Dock = 'Fill'
$LogBox.Margin = '0,6,0,0'
$LogBox.ContextMenu = New-Object System.Windows.Forms.ContextMenu
$LogBox.ContextMenu.MenuItems.AddRange(@(
    (New-Object System.Windows.Forms.MenuItem "Copy",       { $LogBox.Copy() }),
    (New-Object System.Windows.Forms.MenuItem "Select All", { $LogBox.SelectAll() })
))
# Add log to root row 2
$root.Controls.Add($LogBox, 0, 2)

# =========================
# CORE: confirm + post
# =========================
function Confirm-And-Post-Offers {
    param(
        [string]$Phase,                 # "QA" or "Deploy"
        [string]$Server,
        [string]$User,
        [string]$Pass,
        [string]$FixletInstall,
        [string]$FixletUpdate,
        [string]$FixletRemove,
        [string]$OfferDescriptionFromUi
    )

    $LogBox.Clear()
    LogLine "== Begin $Phase Offers =="

    if (-not ($Server -and $User -and $Pass -and $FixletInstall -and $FixletUpdate -and $FixletRemove)) {
        LogLine "❌ Fill Server, Username, Password, and all 3 Fixlet IDs."
        return
    }

    try {
        $base = Get-BaseUrl $Server
        $encodedSite = Encode-SiteName $CustomSiteName
        $auth = Get-AuthHeader -User $User -Pass $Pass
        $postUrl = Join-ApiUrl -BaseUrl $base -RelativePath "/api/actions"
        LogLine "POST URL: ${postUrl}"

        # Pull titles
        $ids = @($FixletInstall,$FixletUpdate,$FixletRemove)
        $titles = @()
        foreach ($fx in $ids) {
            $fixUrl = Join-ApiUrl -BaseUrl $base -RelativePath "/api/fixlet/custom/$encodedSite/$fx"
            $xmlStr = HttpGetXml -Url $fixUrl -AuthHeader $auth
            if ($DumpFetchedXmlToTemp) {
                $tmpFix = Join-Path $env:TEMP ("BES_Fixlet_{0}.xml" -f $fx)
                [System.IO.File]::WriteAllText($tmpFix, $xmlStr)
                LogLine "Saved fetched fixlet XML to: $tmpFix"
            }
            $x = [xml]$xmlStr
            $node = (Get-FixletContainer -Xml $x).Node
            $title = [string]$node.Title
            if (-not $title) { $title = "(Unknown Title: $fx)" }
            $titles += $title
        }

        # Group relevance (hardcoded groups)
        $groupRaw = if ($Phase -ieq "QA") { $QA_GroupIdWithPrefix } else { $Deploy_GroupIdWithPrefix }
        $groupNum = Get-NumericGroupId $groupRaw
        if (-not $groupNum) { throw "Could not parse numeric ID from '$groupRaw'." }
        LogLine "Fetching group relevance for $Phase (group $groupNum)"
        $groupRel = Get-GroupClientRelevance -BaseUrl $base -AuthHeader $auth -SiteName $CustomSiteName -GroupIdNumeric $groupNum

        # Confirm
        $lines = @(
            "Round: $Phase",
            "Group: $groupRaw",
            "Fixlets:",
            " - Install: " + $titles[0],
            " - Update : " + $titles[1],
            " - Remove : " + $titles[2],
            "",
            "Create OFFER actions for these 3 fixlets?"
        )
        $msg = [string]::Join("`r`n",$lines)
        $dlg = [System.Windows.Forms.MessageBox]::Show(
            $form, $msg, "Confirm: Create $Phase Offers",
            [System.Windows.Forms.MessageBoxButtons]::YesNo,
            [System.Windows.Forms.MessageBoxIcon]::Question,
            [System.Windows.Forms.MessageBoxDefaultButton]::Button2
        )
        if ($dlg -ne [System.Windows.Forms.DialogResult]::Yes) {
            LogLine "🚫 User canceled."
            return
        }

        # Post each
        $triples = @(
            @{ Name="Install"; FixId=$FixletInstall; Title=$titles[0] },
            @{ Name="Update";  FixId=$FixletUpdate;  Title=$titles[1] },
            @{ Name="Remove";  FixId=$FixletRemove;  Title=$titles[2] }
        )

        foreach ($t in $triples) {
            $dispName = Parse-FixletTitleToProduct -Title $t.Title
            $xmlBody = Build-OfferXml `
                -UiBaseTitle          $t.Title `
                -DisplayName          $dispName `
                -SiteName             $CustomSiteName `
                -FixletId             $t.FixId `
                -FixletActionName     $FixletActionName_Default `
                -GroupRelevance       $groupRel `
                -Kind                 $t.Name `
                -Phase                $Phase `
                -OfferDescription     $OfferDescriptionFromUi

            $safeTitle = ($t.Name -replace '[^\w\-. ]','_') -replace '\s+','_'
            $tmpAction = Join-Path $env:TEMP ("BES_Offer_{0}_{1:yyyyMMdd_HHmmss}.xml" -f $safeTitle,(Get-Date))
            if ($SaveActionXmlToTemp) {
                [System.IO.File]::WriteAllText($tmpAction, $xmlBody)
                LogLine "Saved OFFER action XML for $($t.Name) to: $tmpAction"
                LogLine ("curl -k -u USER:PASS -H `"Content-Type: application/xml`" -d @`"$tmpAction`" {0}" -f $postUrl)
            }

            try {
                if ($PostUsingInvokeWebRequest -and (Test-Path $tmpAction)) {
                    Post-XmlFile-InFile -Url $postUrl -User $User -Pass $Pass -XmlFilePath $tmpAction
                } else {
                    LogLine "⚠️ Direct POST path disabled; enable if needed."
                }
                LogLine ("✅ OFFER posted: {0} ({1})" -f $t.Name, $dispName)
            } catch {
                LogLine ("❌ OFFER POST failed for {0}: {1}" -f $t.Name, $_.Exception.Message)
            }
        }

        LogLine "All $Phase offers attempted. Log file: $LogFile"
    }
    catch {
        LogLine ("❌ Fatal error ($Phase): {0}" -f ($_.Exception.GetBaseException().Message))
    }
}

# Wire up buttons
$btnQA.Add_Click({
    Confirm-And-Post-Offers `
        -Phase "QA" `
        -Server $tbServer.Text `
        -User $tbUser.Text `
        -Pass $tbPass.Text `
        -FixletInstall $tbFixletInstall.Text `
        -FixletUpdate  $tbFixletUpdate.Text `
        -FixletRemove  $tbFixletRemove.Text `
        -OfferDescriptionFromUi $tbAppDesc.Text
})
$btnDeploy.Add_Click({
    Confirm-And-Post-Offers `
        -Phase "Deploy" `
        -Server $tbServer.Text `
        -User $tbUser.Text `
        -Pass $tbPass.Text `
        -FixletInstall $tbFixletInstall.Text `
        -FixletUpdate  $tbFixletUpdate.Text `
        -FixletRemove  $tbFixletRemove.Text `
        -OfferDescriptionFromUi $tbAppDesc.Text
})

$form.Topmost = $false
[void]$form.ShowDialog()
